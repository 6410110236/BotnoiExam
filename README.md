# BotnoiExam
แบบทดสอบสำหรับการเข้าฝึกงานสหกิจ DevOps บริษัท  Botnoi Academy

# Programming สำหรับ DevOps 1 : 
ภาพดังกล่าวแสดงถึงผลลัพธ์ของคำสั่ง ip a ที่ใช้ในการตรวจสอบสถานะของอินเทอร์เฟซเครือข่ายบนระบบ Linux โดยคำสั่งนี้จะแสดงรายละเอียดของทุกอินเทอร์เฟซเครือข่ายในระบบ รวมถึง IP Address, MAC Address, สถานะของอินเทอร์เฟซ และการตั้งค่าอื่น ๆ ที่เกี่ยวข้อง จากภาพมีการแบ่งกรอบเป็นสีต่าง ๆ อธิบายรายละเอียดในแต่ละส่วน ดังนี้
กรอบสีเหลือง แสดงข้อมูลของอินเทอร์เฟซ ens4 ซึ่งเป็น Network Interface หรือการ์ดเครือข่ายหลักที่เชื่อมต่อกับเครือข่ายภายนอก คุณสมบัติของอินเทอร์เฟซนี้ประกอบด้วย BROADCAST คือ อินเทอร์เฟซรองรับการส่งข้อมูลแบบกระจาย (Broadcast) ไปยังทุกอุปกรณ์ในเครือข่าย, MULTICAST คือ การรองรับการส่งข้อมูลแบบ Multicast หรือการส่งข้อมูลไปยังกลุ่มอุปกรณ์ที่กำหนด, UP เป็นการแสดงว่าอินเทอร์เฟซกำลังทำงานอยู่, LOWER_UP คือการแสดงว่าอินเทอร์เฟซพร้อมใช้งานในระดับล่าง (Layer 1 หรือ Physical Layer), ขนาด MTU (Maximum Transmission Unit) ของอินเทอร์เฟซนี้คือ 1460 ซึ่งหมายถึงขนาดสูงสุดของแพ็กเก็ตข้อมูลที่ส่งได้คือ 1460 ไบต์ เป็นสถานะ UP และอยู่ในกลุ่ม default
กรอบสีม่วง แสดงที่อยู่ IP แบบ IPv4 ของอินเทอร์เฟซ ens4 ในภาพนี้ อินเทอร์เฟซ ens4 มี IP Address เป็น 10.0.0.7/32 ซึ่ง 10.0.0.7 คือ IP Address ของเครื่อง ส่วน /32 เป็นการกำหนด subnet mask ที่ระบุว่าใช้แค่ IP เดียว (1 IP), metric 100 คือ ค่า metric ที่ใช้ในการกำหนดลำดับความสำคัญในการกำหนดเส้นทาง (route) โดยค่า metric ที่ต่ำกว่าจะมีความสำคัญสูงกว่า และ scope global เป็ยการบ่งบอกว่า IP นี้เป็น IP ในระดับ global scope ซึ่งสามารถเข้าถึงได้จากเครือข่ายภายนอก
กรอบสีแดง แสดงที่อยู่ IP แบบ IPv6 ของอินเทอร์เฟซ ens4, IPv6 Address ที่ปรากฏในภาพนี้คือ fe80::4001:aff:fec0:107/64 ส่วน fe80:: เป็น prefix ของ Link-Local Address ใน IPv6 ซึ่งใช้งานภายในเครือข่ายท้องถิ่นเท่านั้น /64 หมายถึง subnet mask ที่กำหนดให้ครอบคลุม 64 บิตแรกของที่อยู่ IPv6,
scope link เป็นการบ่งบอกว่า IP นี้เป็น IP แบบ Link-Local ซึ่งใช้งานได้เฉพาะภายในเครือข่ายเดียวกันและไม่สามารถเข้าถึงจากภายนอกเครือข่าย

# Programming สำหรับ DevOps 2 : 
ภาพดังกล่าวแสดงโครงสร้างของระบบไฟล์ในระบบปฏิบัติการ Linux โดยเริ่มต้นจาก root directoryโครงสร้างนี้เป็นมาตรฐานของระบบไฟล์ใน Linux ที่จัดระเบียบไฟล์และโฟลเดอร์ตามประเภ ทและหน้าที่การทำงาน
/bin/ คือ path ที่ใช้เก็บไฟล์โปรแกรมพื้นฐานและคำสั่งที่จำเป็นในการใช้งาน เช่น ls, cp, mv ซึ่งคำสั่งเหล่านี้ใช้ได้โดยผู้ใช้ทุกคน
/boot/ คือ path ที่ใช้เก็บไฟล์ที่ใช้ในการบูตระบบ เช่น kernel (ไฟล์ระบบหลักของ Linux) และไฟล์การตั้งค่าการบูตของระบบปฏิบัติการ
/dev/ คือ path ที่ใช้เก็บไฟล์อุปกรณ์ (device files) ที่ใช้ในการเชื่อมต่อกับอุปกรณ์ฮาร์ดแวร์ต่าง ๆ เช่น ไฟล์ที่ใช้สำหรับเข้าถึงดิสก์, หน่วยความจำ หรืออุปกรณ์เชื่อมต่ออื่น ๆ
/etc/ คือ path ที่ใช้เก็บไฟล์การตั้งค่าระบบและไฟล์กำหนดค่าของโปรแกรมต่าง ๆ ที่ติดตั้งในระบบ ไฟล์เหล่านี้มักเป็นไฟล์ข้อความที่สามารถแก้ไขได้โดยผู้ดูแลระบบ
/home/ คือ path ที่ใช้เก็บไดเรกทอรีย่อยของผู้ใช้แต่ละคน ไฟล์และการตั้งค่าส่วนตัวของผู้ใช้จะถูกเก็บไว้ในไดเรกทอรีนี้ เช่น /home/username/
/lib/ คือ path เก็บไลบรารี (library) ที่จำเป็นสำหรับการทำงานของโปรแกรมใน /bin/ และ /sbin/ ไลบรารีเหล่านี้มีบทบาทคล้ายกับไลบรารีในระบบปฏิบัติการอื่น ๆ
/media/ คือ path ที่ใช้สำหรับการเชื่อมต่อและติดตั้งอุปกรณ์ภายนอก เช่น USB, CD-ROM ไดเรกทอรีนี้ช่วยให้สามารถเข้าถึงอุปกรณ์ได้อย่างง่ายดาย
/mnt/ เป็นไดเรกทอรีที่ใช้สำหรับติดตั้งอุปกรณ์ภายนอกชั่วคราว เช่น การเชื่อมต่อฮาร์ดดิสก์เพิ่มเติม หรือเน็ตเวิร์กไดรฟ์
/opt/ ใช้สำหรับเก็บซอฟต์แวร์เพิ่มเติมที่ไม่ได้มาพร้อมกับระบบ เช่น ซอฟต์แวร์ที่ติดตั้งเพิ่มเติมจากภายนอก
/root/ เป็นไดเรกทอรีหลักของผู้ใช้ root หรือผู้ดูแลระบบ โดยทั่วไปผู้ใช้คนอื่นจะไม่สามารถเข้าถึงไดเรกทอรีนี้ได้
/sbin/ คือ path ที่ใช้เก็บคำสั่งระบบและโปรแกรมที่ใช้ในการดูแลระบบ เช่น คำสั่งที่จำเป็นสำหรับผู้ดูแลระบบ โดยเฉพาะคำสั่งที่ต้องใช้สิทธิ์ root ในการใช้งาน
/srv/ คือ path ที่ใช้เก็บข้อมูลที่ให้บริการในเซิร์ฟเวอร์ เช่น ข้อมูลเว็บเซิร์ฟเวอร์, ไฟล์เซิร์ฟเวอร์ หรือฐานข้อมูล
/tmp/ เป็นไดเรกทอรีสำหรับไฟล์ชั่วคราว ไฟล์ที่ถูกสร้างขึ้นในไดเรกทอรีนี้มักจะถูกลบออกเมื่อระบบรีบูตหรือเมื่อเวลาผ่านไป
/usr/ คือ path ที่ใช้เก็บไฟล์โปรแกรมและไฟล์ระบบที่ใช้โดยผู้ใช้ทั่วไปและเป็นที่เก็บไฟล์ที่จำเป็นสำหรับการทำงานของซอฟต์แวร์ภายนอก เช่น ไลบรารี โปรแกรม และคำสั่งต่าง ๆ มีการจัดเก็บย่อย ดังนี้:
/usr/bin/: เก็บคำสั่งทั่วไปที่ใช้โดยผู้ใช้ทุกคน
/usr/include/: เก็บไฟล์เฮดเดอร์ที่ใช้สำหรับการพัฒนาโปรแกรม
/usr/lib/: เก็บไลบรารีที่โปรแกรมใน /usr/bin/ ใช้
/usr/sbin/: เก็บคำสั่งที่ใช้สำหรับการดูแลระบบ
/var/ คือ path ที่ใช้เก็บไฟล์ที่มีการเปลี่ยนแปลงบ่อย เช่น ไฟล์บันทึก (log files), แคช, อีเมล และไฟล์ชั่วคราวต่าง ๆ มีการจัดเก็บย่อย ดังนี้:
/var/cache/: เก็บไฟล์แคชจากการทำงานของโปรแกรมต่าง ๆ
/var/log/: เก็บไฟล์บันทึกเหตุการณ์ของระบบและโปรแกรม
/var/spool/: เก็บไฟล์ที่รอการประมวลผล เช่น งานพิมพ์หรืออีเมล
/var/tmp/: เก็บไฟล์ชั่วคราวที่ต้องการอยู่ได้นานกว่าไฟล์ใน /tmp/

# Programming สำหรับ DevOps 3 : 
ภาพดังกล่าวแสดงถึงกระบวนการทำงานของ การสร้างและเรียกใช้งานโปรเซสในระบบ Unix/Linux ตั้งแต่การเริ่มต้นใช้งาน shell จนถึงการประมวลผลคำสั่ง echo "Hi". ภาพแสดงลำดับการทำงานของโปรเซสและการใช้งาน file descriptors (fd) รวมถึงคำสั่ง fork และ wait ซึ่งเป็นคำสั่งที่ใช้ในกระบวนการสร้างโปรเซสใหม่
การทำงานในภาพนี้สามารถอธิบายได้ดังนี้:
1. การเริ่มต้นของ init Process : กระบวนการทั้งหมดเริ่มต้นจาก init ซึ่งเป็นโปรเซสแรกสุดในระบบ Unix/Linux มี Process ID (PID) เป็น 1 เสมอ ซึ่ง init จะสร้างกระบวนการอื่น ๆ ในระบบ ซึ่งในที่นี้คือโปรเซส -bash
2. -bash Process (Shell Process) : -bash เป็น shell process หรือคำสั่ง shell ที่ผู้ใช้ใช้งานผ่าน terminal
ในที่นี้ -bash จะรับคำสั่งจากผู้ใช้ โดยในภาพคำสั่งนั้นคือ echo "Hi" -bash จะทำการสร้างโปรเซสลูกโดยใช้คำสั่ง fork และรอโปรเซสลูกทำงานโดยใช้คำสั่ง wait
3. การสร้างและการทำงานของ runc Process : เมื่อ -bash เรียก fork เพื่อสร้างโปรเซสลูกใหม่ที่เป็น runc
runc เป็นโปรเซสที่ใช้สำหรับการเรียกใช้งานและจัดการ container ในระบบ Linux ที่สนับสนุน container เช่น Docker, runc จะทำการเรียก fork เพื่อสร้างโปรเซสลูกอีกโปรเซสหนึ่ง ซึ่งทำหน้าที่ในการประมวลผลคำสั่งต่อไป โดย runc แต่ละตัวจะมี file descriptors (fd) 0, 1, และ 2 ซึ่งหมายถึง standard input (stdin), standard output (stdout), และ standard error (stderr) ที่ใช้ในการรับส่งข้อมูล
4. sh Process : sh เป็น shell ที่ถูกเรียกใช้โดย runc เพื่อประมวลผลคำสั่งที่ได้รับจาก -bash ในภาพนี้ คำสั่งที่ sh จะประมวลผลคือ echo "Hi" เช่นเดียวกับโปรเซสก่อนหน้า sh ใช้ fork เพื่อสร้างโปรเซสลูกสำหรับการประมวลผลคำสั่ง echo
5. echo "Hi" Process : echo เป็นคำสั่งที่ใช้ในการพิมพ์ข้อความไปยัง stdout ซึ่งในที่นี้จะพิมพ์คำว่า "Hi"
ข้อความ "Hi" จะถูกส่งกลับไปยัง file descriptor 1 (stdout) ซึ่งเชื่อมต่อกับ terminal ทำให้ผู้ใช้สามารถเห็นผลลัพธ์ของคำสั่ง
6. การใช้งาน File Descriptors : File descriptors 0, 1, และ 2 เป็นการเชื่อมต่อระหว่างโปรเซสและ terminal:
fd 0 คือ standard input (stdin) ที่รับข้อมูลจากผู้ใช้
fd 1 คือ standard output (stdout) ที่ส่งข้อมูลไปยังผู้ใช้
fd 2 คือ standard error (stderr) ที่ส่งข้อความข้อผิดพลาดไปยังผู้ใช้
ในการประมวลผล คำสั่ง echo "Hi" จะส่งข้อมูล "Hi" ไปที่ stdout (fd 1) ทำให้ผู้ใช้เห็นข้อความบนหน้าจอ
7. การเชื่อมโยง Parent Process (PPID = 1) : การเชื่อมโยงที่แสดงในภาพด้วยเส้นประ เป็นการแสดงถึง Parent Process ID (PPID) โดย -bash จะมี PPID = 1 ซึ่งหมายความว่ามี init เป็น parent process กระบวนการ fork จะทำให้เกิดกระบวนการลูกที่มี PID แตกต่างจาก parent และ wait จะทำให้ parent รอจนกว่า process ลูกจะสิ้นสุดการทำงาน
